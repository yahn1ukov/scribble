package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"github.com/google/uuid"
	"github.com/yahn1ukov/scribble/apps/gateway/internal/gql/gqlmodels"
	"github.com/yahn1ukov/scribble/libs/grpc"
	filepb "github.com/yahn1ukov/scribble/proto/file"
	notepb "github.com/yahn1ukov/scribble/proto/note"
	"io"
)

func (r *mutationResolver) CreateNote(ctx context.Context, notebookID uuid.UUID, input gqlmodels.CreateNoteInput) (bool, error) {
	res, err := r.noteClient.CreateNote(
		ctx,
		&notepb.CreateNoteRequest{
			NotebookId: notebookID.String(),
			Title:      input.Title,
			Content:    input.Content,
		},
	)
	if err != nil {
		return false, grpc.ParseError(err).Error()
	}

	stream, err := r.fileClient.UploadAllFiles(ctx)
	if err != nil {
		return false, grpc.ParseError(err).Error()
	}

	for _, file := range input.Files {
		content, err := io.ReadAll(file.File)
		if err != nil {
			return false, err
		}

		if err = stream.Send(
			&filepb.UploadFileRequest{
				NoteId:      res.Id,
				Name:        file.Filename,
				Size:        file.Size,
				ContentType: file.ContentType,
				Content:     content,
			},
		); err != nil {
			return false, grpc.ParseError(err).Error()
		}
	}

	if err = stream.CloseSend(); err != nil {
		return false, err
	}

	if _, err = stream.CloseAndRecv(); err != nil {
		return false, grpc.ParseError(err).Error()
	}

	return true, nil
}

func (r *mutationResolver) UpdateNote(ctx context.Context, id uuid.UUID, notebookID uuid.UUID, input gqlmodels.UpdateNoteInput) (bool, error) {
	if _, err := r.noteClient.UpdateNote(
		ctx,
		&notepb.UpdateNoteRequest{
			Id:         id.String(),
			NotebookId: notebookID.String(),
			Title:      input.Title,
			Content:    input.Content,
		},
	); err != nil {
		return false, grpc.ParseError(err).Error()
	}

	return true, nil
}

func (r *mutationResolver) DeleteNote(ctx context.Context, id uuid.UUID, notebookID uuid.UUID) (bool, error) {
	if _, err := r.noteClient.DeleteNote(
		ctx,
		&notepb.DeleteNoteRequest{
			Id:         id.String(),
			NotebookId: notebookID.String(),
		},
	); err != nil {
		return false, grpc.ParseError(err).Error()
	}

	return true, nil
}

func (r *queryResolver) Note(ctx context.Context, id uuid.UUID, notebookID uuid.UUID) (*gqlmodels.Note, error) {
	resNote, err := r.noteClient.GetNote(
		ctx,
		&notepb.GetNoteRequest{
			Id:         id.String(),
			NotebookId: notebookID.String(),
		},
	)
	if err != nil {
		return nil, grpc.ParseError(err).Error()
	}

	resFiles, err := r.fileClient.ListFiles(
		ctx,
		&filepb.ListFilesRequest{
			NoteId: id.String(),
		},
	)
	if err != nil {
		return nil, grpc.ParseError(err).Error()
	}

	var files []*gqlmodels.File
	for _, file := range resFiles.Files {
		files = append(
			files,
			&gqlmodels.File{
				ID:          uuid.MustParse(file.Id),
				Name:        file.Name,
				Size:        file.Size,
				ContentType: file.ContentType,
				CreatedAt:   file.CreatedAt.AsTime(),
			},
		)
	}

	output := &gqlmodels.Note{
		ID:        uuid.MustParse(resNote.Id),
		Title:     resNote.Title,
		Content:   resNote.Content,
		CreatedAt: resNote.CreatedAt.AsTime(),
		Files:     files,
	}

	return output, nil
}

func (r *queryResolver) Notes(ctx context.Context, notebookID uuid.UUID) ([]*gqlmodels.Note, error) {
	res, err := r.noteClient.ListNotes(
		ctx,
		&notepb.ListNotesRequest{
			NotebookId: notebookID.String(),
		},
	)
	if err != nil {
		return nil, grpc.ParseError(err).Error()
	}

	var output []*gqlmodels.Note
	for _, note := range res.Notes {
		output = append(
			output,
			&gqlmodels.Note{
				ID:        uuid.MustParse(note.Id),
				Title:     note.Title,
				Content:   note.Content,
				CreatedAt: note.CreatedAt.AsTime(),
			},
		)
	}

	return output, nil
}
