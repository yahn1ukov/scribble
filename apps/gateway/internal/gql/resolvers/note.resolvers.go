package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"io"

	"github.com/google/uuid"
	"github.com/yahn1ukov/scribble/apps/gateway/internal/gql/gqlmodels"
	"github.com/yahn1ukov/scribble/apps/gateway/internal/gql/graph"
	"github.com/yahn1ukov/scribble/libs/grpc"
	filepb "github.com/yahn1ukov/scribble/proto/file"
	notepb "github.com/yahn1ukov/scribble/proto/note"
)

func (r *mutationResolver) CreateNote(ctx context.Context, notebookID uuid.UUID, input gqlmodels.CreateNoteInput) (bool, error) {
	note, err := r.noteClient.CreateNote(
		ctx,
		&notepb.CreateNoteRequest{
			NotebookId: notebookID.String(),
			Title:      input.Title,
			Content:    input.Content,
		},
	)
	if err != nil {
		return false, grpc.ParseError(err).Error()
	}

	stream, err := r.fileClient.UploadAllFiles(ctx)
	if err != nil {
		return false, grpc.ParseError(err).Error()
	}

	for _, file := range input.Files {
		content, err := io.ReadAll(file.File)
		if err != nil {
			return false, err
		}

		if err = stream.Send(
			&filepb.UploadFileRequest{
				NoteId:      note.Id,
				Name:        file.Filename,
				Size:        file.Size,
				ContentType: file.ContentType,
				Content:     content,
			},
		); err != nil {
			return false, grpc.ParseError(err).Error()
		}
	}

	if err = stream.CloseSend(); err != nil {
		return false, err
	}

	if _, err = stream.CloseAndRecv(); err != nil {
		return false, grpc.ParseError(err).Error()
	}

	return true, nil
}

func (r *mutationResolver) UpdateNote(ctx context.Context, id uuid.UUID, notebookID uuid.UUID, input gqlmodels.UpdateNoteInput) (bool, error) {
	if _, err := r.noteClient.UpdateNote(
		ctx,
		&notepb.UpdateNoteRequest{
			Id:         id.String(),
			NotebookId: notebookID.String(),
			Title:      input.Title,
			Content:    input.Content,
		},
	); err != nil {
		return false, grpc.ParseError(err).Error()
	}

	return true, nil
}

func (r *mutationResolver) DeleteNote(ctx context.Context, id uuid.UUID, notebookID uuid.UUID) (bool, error) {
	if _, err := r.noteClient.DeleteNote(
		ctx,
		&notepb.DeleteNoteRequest{
			Id:         id.String(),
			NotebookId: notebookID.String(),
		},
	); err != nil {
		return false, grpc.ParseError(err).Error()
	}

	return true, nil
}

func (r *noteResolver) Files(ctx context.Context, obj *gqlmodels.Note) ([]*gqlmodels.File, error) {
	files, err := r.fileClient.ListFiles(
		ctx,
		&filepb.ListFilesRequest{
			NoteId: obj.ID.String(),
		},
	)
	if err != nil {
		return nil, grpc.ParseError(err).Error()
	}

	output := make([]*gqlmodels.File, 0, len(files.Files))
	for _, file := range files.Files {
		mappedFile := r.mapper.GRPCFileToFile(file)
		output = append(output, &mappedFile)
	}

	return output, nil
}

func (r *queryResolver) Note(ctx context.Context, id uuid.UUID, notebookID uuid.UUID) (*gqlmodels.Note, error) {
	note, err := r.noteClient.GetNote(
		ctx,
		&notepb.GetNoteRequest{
			Id:         id.String(),
			NotebookId: notebookID.String(),
		},
	)
	if err != nil {
		return nil, grpc.ParseError(err).Error()
	}

	output := r.mapper.GRPCNoteToNote(note)

	return &output, nil
}

func (r *queryResolver) Notes(ctx context.Context, notebookID uuid.UUID) ([]*gqlmodels.Note, error) {
	notes, err := r.noteClient.ListNotes(
		ctx,
		&notepb.ListNotesRequest{
			NotebookId: notebookID.String(),
		},
	)
	if err != nil {
		return nil, grpc.ParseError(err).Error()
	}

	var output []*gqlmodels.Note
	for _, note := range notes.Notes {
		mappedNote := r.mapper.GRPCNoteToNote(note)
		output = append(output, &mappedNote)
	}

	return output, nil
}

func (r *Resolver) Note() graph.NoteResolver { return &noteResolver{r} }

type noteResolver struct{ *Resolver }
